#!/bin/bash

# 스크립트를 실행할 때 사용자로부터 받은 첫 번째 인자를 message_file 변수에 저장합니다. 이 인자는 커밋 메시지가 있는 파일의 경로입니다.
message_file="$1"
# 현재 Git 저장소의 디렉토리 경로를 git_dir 변수에 저장합니다.
git_dir=$(git rev-parse --git-dir)

# `message_file` 변수에 저장된 파일을 읽어서 message 변수에 저장합니다. 이는 커밋 메시지 내용을 나타냅니다.
message=$(cat "$message_file")
# 현재 작업 중인 브랜치의 이름을 current_branch 변수에 저장합니다.
current_branch=$(git rev-parse --abbrev-ref HEAD)
# `services` 변수에는 일련의 서비스 이름을 정규 표현식으로 나타낸 문자열이 저장됩니다.
# services='(alba-talk|business|personal|services|shared|root)'
# `default_pattern` 변수에는 커밋 메시지가 일정한 패턴을 따르는지 확인하기 위한 정규 표현식이 저장됩니다. 이 패턴은 다양한 작업 유형 (Add, Remove, Fix 등)을 포함하며, 선택적으로 services 문자열과 일치할 수 있습니다.
# default_pattern="^(\($services\) )?(Add|Remove|Fix|Modify|Improve|Simplify|Refactor|Merge|Move)"
default_pattern="^(\(Add|Remove|Fix|Modify|Improve|Simplify|Refactor|Merge|Move\) )"
# `ticket_pattern` 변수에는 티켓 번호 패턴을 정규 표현식으로 나타낸 문자열이 저장됩니다. 예를 들어, "FRONTEND-123"과 같은 티켓 번호를 나타내는 형식입니다.
ticket_pattern='FRONTEND-[0-9]+'
# 초기에 빈 문자열로 초기화된 변수입니다.
target_service=''
# 초기에 빈 문자열로 초기화된 변수입니다.
target_ticket=''




# Git 저장소에서 Rebase 작업이 진행 중인지 확인하는 조건문입니다. 만약 Rebase 작업 중이라면 스크립트를 즉시 종료합니다.
# if test -d "$git_dir/rebase-merge"; then
#   # Rebase in progress
#   # Exit immediately
#   exit 0
# fi




# 커밋 메시지가 default_pattern에 일치하지 않는 경우를 확인하는 조건문입니다. 이 경우, 커밋 메시지가 지정된 규칙을 따르지 않는다는 경고 메시지가 출력되고 스크립트가 종료됩니다.
if [[ ! $message =~ $default_pattern ]]; then
  echo '🚨 Git 컨벤션을 준수해주세요! 👮'
#   echo 'https://wiki.jobkorea.co.kr/display/FEDEV/Git'
  echo ''
  echo '🏃      🚓💨💨'
  osascript -e 'display notification "🚨 Git 컨벤션을 준수해주세요! 👮" with title "컨벤션 경고"'
  exit 1
fi




# 커밋 메시지가 `services` 문자열과 일치하지 않는 경우를 확인하는 조건문입니다. 
# 이 경우, 변경된 파일 중에서 apps 또는 libs 디렉토리에서 해당 `services`에 해당하는 것을 찾아내고, 그 중 가장 빈도수가 높은 서비스를 target_service 변수에 저장합니다. 
# 디렉토리에서 파일을 검색하기 위해 정규 표현식을 사용하고, grep 및 awk를 사용하여 작업을 수행합니다.
# if [[ ! $message =~ ^\($services\) ]]; then
#   tmp=()
#   files_changed=$(git diff --name-only HEAD)
#   dir_pattern="(apps|libs)\/$services"

#   # I can't use -P in mac's default bash ;(
#   # grep -P -E -o '(apps|libs)\/\K(alba-talk|business|personal|services|shared)' <<<$files_changed | sort -r | uniq -c | sort -n | tail -1

#   for file in $files_changed; do
#     if [[ $file =~ $dir_pattern ]]; then
#       service="${BASH_REMATCH[2]}"
#       tmp+=("$service")
#     fi
#   done

#   if ((${#tmp[@]})); then
#     target_service=$(printf '%s\n' "${tmp[@]}" | sort -r | uniq -c | sort -n | tail -1 | awk '{print $2}')
#     # Yes I think this is so weird, but I'm noob to bash.
#     # And to be honest, bash has always been weird too.
#     target_service="($target_service) "
#   else
#     target_service="(root) "
#   fi
# fi




# 커밋 메시지에 `ticket_pattern` 패턴이 포함되어 있지 않은 경우를 확인하는 조건문입니다. 현재 작업 중인 브랜치 이름에서 `ticket_pattern`과 일치하는 티켓 번호를 추출하여 target_ticket 변수에 저장합니다.
# if [[ ! $message =~ \[$ticket_pattern\]$ ]]; then
#   if [[ $current_branch =~ $ticket_pattern ]]; then
#     target_ticket="

# [${BASH_REMATCH[0]}]"
#   fi
# fi



#  최종적으로, `target_service`, `message`, `target_ticket`을 조합하여 새로운 커밋 메시지를 생성하고, 이를 `message_file`에 덮어씁니다.
# echo "$target_service$message$target_ticket" >$message_file




# 스크립트가 정상적으로 종료되었음을 나타내는 코드입니다.
exit 0
